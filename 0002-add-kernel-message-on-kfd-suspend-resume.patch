From 42dbb859bc0f85ffcbcde4e258a5a563c125d6bd Mon Sep 17 00:00:00 2001
From: Djip007 <djip.perois@free.fr>
Date: Tue, 7 May 2019 14:37:31 +0200
Subject: [PATCH 2/3] add kernel message on kfd suspend/resume

---
 drivers/gpu/drm/amd/amdkfd/kfd_device.c | 30 +++++++++++++++++++++----
 1 file changed, 26 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_device.c b/drivers/gpu/drm/amd/amdkfd/kfd_device.c
index 4bfedaab183f..9385b27b979b 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_device.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_device.c
@@ -527,6 +527,7 @@ static int kfd_gtt_sa_init(struct kfd_dev *kfd, unsigned int buf_size,
 				unsigned int chunk_size);
 static void kfd_gtt_sa_fini(struct kfd_dev *kfd);
 
+static void kfd_suspend(struct kfd_dev *kfd);
 static int kfd_resume(struct kfd_dev *kfd);
 
 struct kfd_dev *kgd2kfd_probe(struct kgd_dev *kgd,
@@ -790,8 +791,13 @@ bool kgd2kfd_device_init(struct kfd_dev *kfd,
 
 void kgd2kfd_device_exit(struct kfd_dev *kfd)
 {
+	dev_info(kfd_device, "exit device: %x:%x\n", kfd->pdev->vendor, kfd->pdev->device);
+
 	if (kfd->init_complete) {
-		kgd2kfd_suspend(kfd, false);
+		/* For first KFD device suspend all the KFD processes */
+		if (atomic_inc_return(&kfd_locked) == 1)
+			kfd_suspend_all_processes();
+		kfd_suspend(kfd);
 		device_queue_manager_uninit(kfd->dqm);
 		kfd_interrupt_exit(kfd);
 		kfd_topology_remove_device(kfd);
@@ -809,10 +815,15 @@ int kgd2kfd_pre_reset(struct kfd_dev *kfd)
 {
 	if (!kfd->init_complete)
 		return 0;
+	dev_info(kfd_device, "pre reset device %x:%x\n", kfd->pdev->vendor, kfd->pdev->device);
 
 	kfd->dqm->ops.pre_reset(kfd->dqm);
 
-	kgd2kfd_suspend(kfd, false);
+	/* For first KFD device suspend all the KFD processes */
+	if (atomic_inc_return(&kfd_locked) == 1)
+		kfd_suspend_all_processes();
+
+	kfd_suspend(kfd);
 
 	kfd_signal_reset_event(kfd);
 	return 0;
@@ -830,6 +841,7 @@ int kgd2kfd_post_reset(struct kfd_dev *kfd)
 
 	if (!kfd->init_complete)
 		return 0;
+	dev_info(kfd_device, "post reset device %x:%x\n", kfd->pdev->vendor, kfd->pdev->device);
 
 	ret = kfd_resume(kfd);
 	if (ret)
@@ -843,6 +855,9 @@ int kgd2kfd_post_reset(struct kfd_dev *kfd)
 
 bool kfd_is_locked(void)
 {
+	if (atomic_read(&kfd_locked) > 0) {
+		dev_warn(kfd_device, "devices are locked (suspend?)\n");
+	}
 	return  (atomic_read(&kfd_locked) > 0);
 }
 
@@ -850,6 +865,7 @@ void kgd2kfd_suspend(struct kfd_dev *kfd, bool run_pm)
 {
 	if (!kfd->init_complete)
 		return;
+	dev_info(kfd_device, "suspend device %x:%x\n", kfd->pdev->vendor, kfd->pdev->device);
 
 	/* for runtime suspend, skip locking kfd */
 	if (!run_pm) {
@@ -858,8 +874,7 @@ void kgd2kfd_suspend(struct kfd_dev *kfd, bool run_pm)
 			kfd_suspend_all_processes();
 	}
 
-	kfd->dqm->ops.stop(kfd->dqm);
-	kfd_iommu_suspend(kfd);
+	kfd_suspend(kfd);
 }
 
 int kgd2kfd_resume(struct kfd_dev *kfd, bool run_pm)
@@ -868,6 +883,7 @@ int kgd2kfd_resume(struct kfd_dev *kfd, bool run_pm)
 
 	if (!kfd->init_complete)
 		return 0;
+	dev_info(kfd_device, "resume device %x:%x\n", kfd->pdev->vendor, kfd->pdev->device);
 
 	ret = kfd_resume(kfd);
 	if (ret)
@@ -884,6 +900,12 @@ int kgd2kfd_resume(struct kfd_dev *kfd, bool run_pm)
 	return ret;
 }
 
+static void kfd_suspend(struct kfd_dev *kfd)
+{
+	kfd->dqm->ops.stop(kfd->dqm);
+	kfd_iommu_suspend(kfd);
+}
+
 static int kfd_resume(struct kfd_dev *kfd)
 {
 	int err = 0;
-- 
2.29.2

